<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arbre de Diagnostic Automobile - Vue Graphique</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="m-0 font-sans bg-slate-100">
    <div class="flex h-screen overflow-hidden">
        <div class="w-64 bg-white p-5 shadow-lg overflow-y-auto z-10" id="sidebar">
            <h2 class="text-xl font-bold mb-4">Menu</h2>
        </div>
        <div class="flex-grow relative overflow-hidden p-0" id="tree-container"></div>
    </div>
    <div class="fixed bottom-5 right-5 bg-white p-2 rounded-lg shadow-md flex gap-2">
        <button class="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600" onclick="zoomIn()">+</button>
        <button class="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600" onclick="zoomOut()">-</button>
        <button class="px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600" onclick="resetZoom()">Reset</button>
    </div>

    <script>
        const margin = {top: 20, right: 50, bottom: 30, left: 50};
        const width = 1500 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        const svg = d3.select("#tree-container")
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("class", "cursor-grab active:cursor-grabbing");

        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const tree = d3.tree()
            .size([height, width])
            .separation((a, b) => (a.parent == b.parent ? 1 : 1.2));

        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => g.attr("transform", event.transform));

        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        let currentTransform = d3.zoomTransform(svg.node());

        svg.call(zoom);

        function zoomIn() {
            svg.transition().duration(300).call(zoom.scaleBy, 1.2);
        }

        function zoomOut() {
            svg.transition().duration(300).call(zoom.scaleBy, 0.8);
        }

        function resetZoom() {
            svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity.translate(margin.left, margin.top));
        }

        svg
            .on("contextmenu", (event) => event.preventDefault())
            .on("mousedown", (event) => {
                if (event.button === 2) {
                    isDragging = true;
                    lastX = event.clientX;
                    lastY = event.clientY;
                    currentTransform = d3.zoomTransform(svg.node());
                }
            })
            .on("mousemove", (event) => {
                if (isDragging) {
                    event.preventDefault();
                    const dx = event.clientX - lastX, dy = event.clientY - lastY;
                    lastX = event.clientX;
                    lastY = event.clientY;
                    currentTransform = currentTransform.translate(dx, dy);
                    g.attr("transform", currentTransform);
                    zoom.transform(svg, currentTransform);
                }
            })
            .on("mouseup", (event) => { if (event.button === 2) isDragging = false; })
            .on("mouseleave", () => { isDragging = false; });

        async function loadAndDisplayTree(filename) {
            try {
                const response = await fetch(`arbre/${filename}`);
                const data = await response.json();
                displayTree(data);
            } catch (error) {
                console.error(`Erreur lors du chargement du fichier ${filename}:`, error);
            }
        }

        function processData(data) {
            function processNode(node) {
                if (node.options && Array.isArray(node.options)) {
                    node.children = node.options.map(option => {
                        option.answer = option.text;
                        return processNode(option);
                    });
                }
                return node;
            }
            return processNode(data);
        }

        function displayTree(data) {
            g.selectAll("*").remove();

            const hierarchyData = d3.hierarchy(processData(data));
            const treeData = tree(hierarchyData);

            g.selectAll(".link")
                .data(treeData.links())
                .enter().append("path")
                .attr("class", "fill-none stroke-gray-300 stroke-2")
                .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));

            const nodes = g.selectAll("g.node")
                .data(treeData.descendants())
                .enter().append("g")
                .attr("class", "cursor-pointer")
                .attr("transform", d => `translate(${d.y},${d.x})`);

            nodes.append("circle")
                .attr("r", 5)
                .attr("class", "fill-white stroke-blue-500 stroke-2");

            g.selectAll("text.link-label")
                .data(treeData.links())
                .enter()
                .append("text")
                .attr("class", "text-xs fill-gray-600")
                .attr("x", d => (d.source.y + d.target.y) / 2 + 10)
                .attr("y", d => (d.source.x + d.target.x) / 2 - 5)
                .attr("text-anchor", "middle")
                .text(d => d.target.data.answer || "");

            nodes.append("foreignObject")
                .attr("x", 10)
                .attr("y", -35)
                .attr("width", 250)
                .attr("height", 120)
                .append("xhtml:div")
                .attr("class", "bg-white p-3 rounded-md shadow-md max-w-[250px] text-sm leading-tight pointer-events-none")
                .html(d => {
                    let content = "";
                    if (d.data.question) {
                        content += `<strong class="text-base block mb-1">Question:</strong>${d.data.question}`;
                    } else if (d.data.type === 'terminal') {
                        content += `<strong class="text-base block mb-1">Diagnostic:</strong>${d.data.diagnostic || d.data.symptome || 'N/A'}`;
                        if (d.data.hypothese) content += `<br><em class="text-gray-600">Hypoth√®se: ${d.data.hypothese}</em>`;
                    }
                    return content;
                });
        }

        async function loadFileList() {
            try {
                const response = await fetch('arbre/arbre.json');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const menuData = await response.json();
                const menuOptions = menuData.options;

                const sidebar = document.getElementById('sidebar');
                sidebar.innerHTML = '<h2 class="text-xl font-bold mb-4">Menu</h2>';

                menuOptions.forEach(option => {
                    if (option.file_path) {
                        const button = document.createElement('button');
                        button.className = 'block w-full p-2.5 mb-2 bg-blue-500 text-white rounded-md text-left hover:bg-blue-600 transition-colors';
                        button.textContent = option.text;
                        button.onclick = () => loadAndDisplayTree(option.file_path);
                        sidebar.appendChild(button);
                    }
                });

                if (menuOptions.length > 0 && menuOptions[0].file_path) {
                    loadAndDisplayTree(menuOptions[0].file_path);
                }
            } catch (error) {
                console.error('Erreur lors du chargement du menu principal:', error);
                document.getElementById('sidebar').innerHTML = '<h2 class="text-xl font-bold mb-4">Menu</h2><p class="text-red-500">Erreur de chargement du menu.</p>';
            }
        }

        loadFileList();
    </script>
</body>
</html>